@props([
    'id' => null,
    'type' => 'success',
    'title' => 'Notification',
    'message' => '',
    'buttonText' => 'Show Notification',
    'showButton' => true,
    'autoHide' => true,
    'duration' => 5000,
    'position' => 'right',
    'gravity' => 'top',
    'showClose' => true
])

@php
    $toastId = $id ?? 'notification-' . uniqid();
    $contentId = $toastId . '-content';
    $toggleId = $toastId . '-toggle';
    
    $iconClasses = [
        'success' => 'text-success',
        'error' => 'text-danger',
        'warning' => 'text-warning',
        'info' => 'text-info'
    ];
    
    $icons = [
        'success' => 'CheckCircle',
        'error' => 'x-circle',
        'warning' => 'alert-triangle',
        'info' => 'info'
    ];
    
    $iconClass = $iconClasses[$type] ?? $iconClasses['success'];
    $iconName = $icons[$type] ?? $icons['success'];
@endphp

<!-- BEGIN: Notification Content -->
<div id="{{ $contentId }}" class="toastify-content hidden flex">
    @if($type === 'success')
        <svg class="w-6 h-6 text-success mr-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
    @else
        <i class="{{ $iconClass }}" data-lucide="{{ $iconName }}"></i>
    @endif
    <div class="ml-4 mr-8 pr-2">
        <div class="font-medium">{{ $title }}</div>
        @if($message)
            <div class="text-slate-500 mt-1">{{ $message }}</div>
        @endif
        {{ $slot }}
    </div>
</div>
<!-- END: Notification Content -->

@if($showButton)
    <!-- BEGIN: Notification Toggle -->
    <button id="{{ $toggleId }}" class="btn btn-primary">{{ $buttonText }}</button>
    <!-- END: Notification Toggle -->
@endif

@push('scripts')
<script>
document.addEventListener('DOMContentLoaded', function() {
    const notificationContent = document.getElementById('{{ $contentId }}');
    console.log('Notification component {{ $toastId }} loaded');
    console.log('Notification content element found:', !!notificationContent);
    console.log('Toastify available:', typeof Toastify !== 'undefined');
    
    // Function to show notification
    window.showNotification_{{ $toastId }} = function() {
        console.log('showNotification_{{ $toastId }} called');
        console.log('Toastify available:', typeof Toastify !== 'undefined');
        console.log('Notification content available:', !!notificationContent);
        
        // Prevent duplicate notifications - close any existing ones first
        try {
            // Close any existing toastify notifications
            document.querySelectorAll('.toastify').forEach(el => {
                if (el.classList.contains('on')) {
                    el.remove();
                }
            });
            // Also close the global active toast if it exists
            if (window.__globalActiveToast && typeof window.__globalActiveToast.hideToast === 'function') {
                window.__globalActiveToast.hideToast();
            }
        } catch (e) {
            console.log('Error closing existing notifications:', e);
        }
        
        if (typeof Toastify !== 'undefined' && notificationContent) {
            const content = notificationContent.cloneNode(true);
            content.classList.remove('hidden');
            
            // Initialize Lucide icons in the cloned content
            console.log('Cloned content HTML:', content.outerHTML);
            
            if (typeof window.lucide !== 'undefined' && window.lucide.createIcons) {
                // Find the icon element in the cloned content and initialize it
                const iconElement = content.querySelector('[data-lucide]');
                console.log('Icon element found in cloned content:', !!iconElement);
                if (iconElement) {
                    console.log('Icon element:', iconElement);
                    console.log('Icon data-lucide attribute:', iconElement.getAttribute('data-lucide'));
                    console.log('Icon classes:', iconElement.className);
                    
                    // Try to initialize icons specifically for this element
                    setTimeout(() => {
                        window.lucide.createIcons({
                            icons: window.lucide.icons,
                            "stroke-width": 1.5,
                            nameAttr: "data-lucide",
                        });
                        console.log('Lucide icons initialized for notification');
                    }, 100);
                }
            } else {
                console.log('Lucide not available:', typeof window.lucide);
            }
            
            console.log('Creating Toastify notification...');
            
            // Calculate position to be below the bell and profile picture, aligned to the right
            // Get the profile picture element (or bell if profile not found) to calculate position
            const profilePicture = document.querySelector('.intro-x.dropdown.w-8.h-8 .dropdown-toggle');
            const bellIcon = document.querySelector('#notification-bell, .notification.dropdown-toggle');
            let yOffset = 80; // Default fallback
            let xOffset = -20; // Default right alignment
            
            if (profilePicture) {
                const profileRect = profilePicture.getBoundingClientRect();
                // Position it right below the profile picture with more spacing
                // Use getBoundingClientRect for viewport coordinates (not scroll-based)
                yOffset = profileRect.bottom + 25;
                // Align to the right edge of the profile picture area
                xOffset = -(window.innerWidth - profileRect.right) - 20;
            } else if (bellIcon) {
                const bellRect = bellIcon.getBoundingClientRect();
                // Position it right below the bell icon with more spacing
                // Use getBoundingClientRect for viewport coordinates (not scroll-based)
                yOffset = bellRect.bottom + 25;
                // Align to the right edge of the bell icon area
                xOffset = -(window.innerWidth - bellRect.right) - 20;
            } else {
                // Fallback: position below topbar
                const topbar = document.querySelector('.top-bar-boxed');
                if (topbar) {
                    const topbarRect = topbar.getBoundingClientRect();
                    yOffset = topbarRect.bottom + 25;
                }
            }
            
            const toast = Toastify({
                node: content,
                duration: {{ $autoHide ? $duration : 0 }},
                close: {{ $showClose ? 'true' : 'false' }},
                gravity: "{{ $gravity }}",
                position: "{{ $position }}",
                className: "toastify-content notification-popup{{ !$showClose ? ' no-close-button' : '' }}",
                stopOnFocus: true,
                escapeMarkup: false,
                offset: { 
                    x: xOffset, // Right-aligned below bell/profile
                    y: yOffset // Position below bell and profile picture
                },
                style: {
                    zIndex: '99999' // Ensure it's in front of everything
                }
            });
            
            toast.showToast();
            
            // After showing, ensure z-index and positioning are applied to the toast element
            setTimeout(() => {
                const toastElement = document.querySelector('.toastify.on:last-of-type');
                if (toastElement) {
                    // Ensure toast is appended to body (not inside any container)
                    if (toastElement.parentElement !== document.body) {
                        document.body.appendChild(toastElement);
                    }
                    
                    // Force highest z-index and fixed positioning
                    toastElement.style.zIndex = '999999';
                    toastElement.style.setProperty('z-index', '999999', 'important');
                    toastElement.style.position = 'fixed';
                    toastElement.style.setProperty('position', 'fixed', 'important');
                    
                    // Force right positioning - use calculated offset or fallback
                    // xOffset is negative for right alignment, convert to positive right value
                    const rightValue = xOffset < 0 ? Math.abs(xOffset) : 20;
                    toastElement.style.right = rightValue + 'px';
                    toastElement.style.setProperty('right', rightValue + 'px', 'important');
                    toastElement.style.left = 'auto';
                    toastElement.style.setProperty('left', 'auto', 'important');
                    
                    // Ensure top position uses viewport coordinates (not scroll-based)
                    const profilePicture = document.querySelector('.intro-x.dropdown.w-8.h-8 .dropdown-toggle');
                    const bellIcon = document.querySelector('#notification-bell, .notification.dropdown-toggle');
                    let topValue = 80;
                    
                    if (profilePicture) {
                        const profileRect = profilePicture.getBoundingClientRect();
                        topValue = profileRect.bottom + 25;
                    } else if (bellIcon) {
                        const bellRect = bellIcon.getBoundingClientRect();
                        topValue = bellRect.bottom + 25;
                    } else {
                        topValue = yOffset;
                    }
                    
                    toastElement.style.top = topValue + 'px';
                    toastElement.style.setProperty('top', topValue + 'px', 'important');
                    
                    // Remove any conflicting classes that might position it on the left
                    toastElement.classList.remove('toastify-left');
                    toastElement.classList.add('toastify-right');
                    
                    // Force remove any inline left styles that might have been set
                    if (toastElement.style.left && toastElement.style.left !== 'auto') {
                        toastElement.style.left = 'auto';
                        toastElement.style.setProperty('left', 'auto', 'important');
                    }
                    
                    // Hide close button if showClose is false
                    @if(!$showClose)
                    const closeButton = toastElement.querySelector('.toast-close');
                    if (closeButton) {
                        closeButton.style.display = 'none';
                        closeButton.remove();
                    }
                    @endif
                }
            }, 100);
            
            console.log('Toastify notification created');
        } else if (notificationContent) {
            // Fallback: no alerts per requirement
            console.log('Toast fallback:', '{{ $title }}', '{{ $message }}');
        } else {
            console.error('Notification content not found for {{ $toastId }}');
        }
    };
    
    @if($showButton)
    // Button click handler
    const toggleButton = document.getElementById('{{ $toggleId }}');
    if (toggleButton) {
        toggleButton.addEventListener('click', function() {
            window.showNotification_{{ $toastId }}();
        });
    }
    @endif
});
</script>
@endpush

@push('styles')
<style>
/* Hide close button for notifications with no-close-button class */
.toastify.no-close-button .toast-close,
.toastify.no-close-button .toastify-content .toast-close {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
}
/* Adjust padding for notifications without close button */
.toastify.no-close-button .toastify-content {
    padding: 1rem !important;
    padding-top: 1rem !important;
}
</style>
@endpush
